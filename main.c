#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/tile.h"
#include "images/background.h"
#include "images/start.h"
#include "images/info.h"
#include "images/knight.h"
#include "images/tile_2.h"
#include "images/green.h"
#include "images/red.h"
#include "images/bomb.h"
#include "images/key.h"
#include "images/door_locked.h"
#include "images/door_unlocked.h"
#include "images/door_open.h"
#include "images/win.h"
#include "images/lose.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  INFO,
  PLAY,
  WIN,
  LOSE,
};

int mapTiles[10][15];

int doorArrX = 0;
int doorArrY = 8;

void initalizeItems(void) {
  // Initalize green potions
  for (int i = 0; i < 3; i++) {
    int greenX = randint(0, 9);
    int greenY = randint(0, 14);
    while (mapTiles[greenX][greenY] != 0) {
      greenX = randint(0, 9);
      greenY = randint(0, 14);
    }
    drawImageDMA(MAP_POS(greenX), MAP_POS(greenY), 16, 16, green);
    mapTiles[greenX][greenY] = 2;
  }
  // Initalize red potions
  for (int i = 0; i < 3; i++) {
    int redX = randint(0, 9);
    int redY = randint(0, 14);
    while (mapTiles[redX][redY] != 0) {
      redX = randint(0, 9);
      redY = randint(0, 14);
    }
    drawImageDMA(MAP_POS(redX), MAP_POS(redY), 16, 16, red);
    mapTiles[redX][redY] = 3;
  }
  // Initalize bomb
  for (int i = 0; i < 2; i++) {
    int bombX = randint(0, 9);
    int bombY = randint(0, 14);
    while (mapTiles[bombX][bombY] != 0) {
        bombX = randint(0, 9);
        bombY = randint(0, 14);
    }
    drawImageDMA(MAP_POS(bombX), MAP_POS(bombY), 16, 16, bomb);
    mapTiles[bombX][bombY] = 4;
  }
  // Initalize key
  int keyX = randint(0, 9);
  int keyY = randint(0, 14);
  while (mapTiles[keyX][keyY] != 0) {
      keyX = randint(0, 9);
      keyY = randint(0, 14);
  }
  drawImageDMA(MAP_POS(keyX), MAP_POS(keyY), 16, 16, key);
  mapTiles[keyX][keyY] = 5;
  // Initalize locked doorway

  drawImageDMA(MAP_POS(doorArrX), MAP_POS(doorArrY), 16, 16, door_locked);
  mapTiles[doorArrX][doorArrY] = 1;
}


int checkCollision(int x, int y) {
  if (mapTiles[ARR_POS(x)][ARR_POS(y)] == 1) {
    return 0;
  } else if (mapTiles[ARR_POS(x)][ARR_POS(y)] == 2) {
    player1.score += 10;
  } else if (mapTiles[ARR_POS(x)][ARR_POS(y)] == 3) {
    player1.score += 10;
  } else if (mapTiles[ARR_POS(x)][ARR_POS(y)] == 4) {
    player1.score -= 20;
    player1.hitBomb = 1;
  } else if (mapTiles[ARR_POS(x)][ARR_POS(y)] == 5) {
    player1.score += 50;
    player1.hasKey = 1;
    undraw(MAP_POS(doorArrX), MAP_POS(doorArrY), 16, 16, tile_2);
    drawImageDMA(MAP_POS(doorArrX), MAP_POS(doorArrY), 16, 16, door_unlocked);
    drawString(MAP_POS(9), MAP_POS(3), "Press A to unlock door", WHITE);
  }
  return 1;
}


int updateGameplay(void) {

  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 15; j++) {
      mapTiles[i][j] = 0;
    }
  }

  player1.score = 0;

  player1.hasKey = 0;
  player1.hitBomb = 0;

  player1.xPos = MAP_POS(2);
  player1.yPos = MAP_POS(0);

  doorArrX = 0;
  doorArrY = 8;

  initalizeItems();

  drawImageDMA(player1.xPos, player1.yPos, 16, 16, knight);
  mapTiles[ARR_POS(player1.xPos)][ARR_POS(player1.yPos)] = 1;
  int alive = 1;
  while (alive) {
    currentButtons = BUTTONS;
    waitForVBlank();

    drawCenteredString(0, 0, 60, 16, "Score:", WHITE);
    char scoreLabel[3];
    sprintf(scoreLabel, "%d", player1.score);
    undraw(MAP_POS(0), MAP_POS(3), 16, 16, tile_2);
    drawCenteredString(MAP_POS(0), MAP_POS(3), 16, 16, scoreLabel, WHITE);

    undraw(player1.xPos, player1.yPos, 16, 16, tile_2);
    mapTiles[ARR_POS(player1.xPos)][ARR_POS(player1.yPos)] = 0;
    if (KEY_DOWN(BUTTON_DOWN, currentButtons) && !(KEY_DOWN(BUTTON_DOWN, previousButtons))) {
        if (player1.xPos + 16 < HEIGHT && checkCollision(player1.xPos + 16, player1.yPos) != 0) {
          player1.xPos += 16;
        }
    } else if (KEY_DOWN(BUTTON_UP, currentButtons) && !(KEY_DOWN(BUTTON_UP, previousButtons))) {
      if (player1.xPos - 16 >= 0 && checkCollision(player1.xPos - 16, player1.yPos) != 0) {
        player1.xPos -= 16;
      }
    } else if (KEY_DOWN(BUTTON_LEFT, currentButtons) && !(KEY_DOWN(BUTTON_LEFT, previousButtons))) {
      if (player1.yPos - 16 >= 0 && checkCollision(player1.xPos, player1.yPos - 16) != 0) {
        player1.yPos -= 16;
      }
    } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && !(KEY_DOWN(BUTTON_RIGHT, previousButtons))) {
      if (player1.yPos + 16 < WIDTH && checkCollision(player1.xPos, player1.yPos + 16) != 0) {
        player1.yPos += 16;
      }
    } else if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !(KEY_DOWN(BUTTON_SELECT, previousButtons))) {
      return 1;
    } else if (KEY_DOWN(BUTTON_A, currentButtons) && !(KEY_DOWN(BUTTON_A, previousButtons)) && player1.hasKey == 1 && (player1.xPos == MAP_POS(doorArrX) + 16) && (player1.yPos == MAP_POS(doorArrY))) {
      undraw(MAP_POS(doorArrX), MAP_POS(doorArrY), 16, 16, tile_2);
      drawImageDMA(MAP_POS(doorArrX), MAP_POS(doorArrY), 16, 16, door_open);
      mapTiles[doorArrX][doorArrY] = 0;
    } 

    if (player1.xPos == MAP_POS(doorArrX) && player1.yPos == MAP_POS(doorArrY)) {
      drawImageDMA(MAP_POS(doorArrX), MAP_POS(doorArrY), 16, 16, door_unlocked);
      return 2;
      break;
    } else {
      drawImageDMA(player1.xPos, player1.yPos, 16, 16, knight);
    }
    if (player1.hitBomb) {
      return 3;
    }
    mapTiles[ARR_POS(player1.xPos)][ARR_POS(player1.yPos)] = 1;
    previousButtons = currentButtons;
  }
  return 3;
}


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;


  while (1) {
    waitForVBlank(); // Wait for VBlank period to avoid tearing

    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:

        drawFullScreenImageDMA(start);

        if (KEY_DOWN(BUTTON_A, currentButtons) && !(KEY_DOWN(BUTTON_A, previousButtons))) {
          state = PLAY;
        } else if (KEY_DOWN(BUTTON_UP, currentButtons) && !(KEY_DOWN(BUTTON_UP, previousButtons))) {
          state = INFO;
        }
        
        break;
      case INFO:
        drawFullScreenImageDMA(info);

        if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !(KEY_DOWN(BUTTON_SELECT, previousButtons))) {
          state = START;
        }
        
        break;
      case PLAY:
        drawFullScreenImageDMA(background);

        player1.xPos = MAP_POS(2);
        player1.yPos = MAP_POS(0);
        player1.score = 0;
        player1.hasKey = 0;
        player1.hitBomb = 0;

        int returnState = updateGameplay();
        if (returnState == 1) {
          state = START;
        } else if (returnState == 2) {
          state = WIN;
        } else if (returnState == 3) {
          state = LOSE;
        }
        
        break;
      case WIN:
        drawFullScreenImageDMA(win);
        char winLabel[3];
        sprintf(winLabel, "%d", player1.score);
        drawString(94, 180, winLabel, WHITE);
        if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !(KEY_DOWN(BUTTON_SELECT, previousButtons))) {
          state = START;
        }
        break;
      case LOSE:
        drawFullScreenImageDMA(lose);
        char loseLabel[3];
        sprintf(loseLabel, "%d", player1.score);
        drawString(75, 170, loseLabel, WHITE);
        if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !(KEY_DOWN(BUTTON_SELECT, previousButtons))) {
          state = START;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
